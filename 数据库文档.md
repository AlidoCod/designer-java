## 后端技术选型

单机项目

开发框架：Springboot、MybatisPlus

安全框架：SpringSecurity + jwt(token生成) + validation(输入校验)

缓存中间件: Redis

搜索/数据分析引擎：ElasticSearch

消息推送协议：WebSocket

数据库：MySQL



## 后端开发计划

2023/6/19 - 2023/6/20

完成项目基本搭建：登录、注册

2023/6/21

1. 开发用户信息模块
   1. 用户登录
   2. 用户基本信息更新
   3. 用户注销（不重要，未实现）
   4. 用户修改密码（不重要，未实现）
2. 开发资源文件上传、下载模块
   1. 文件上传
   2. 文件下载

2023/6/22

1. 配置WebSocket服务器
2. 开发消息提醒模块

2023/6/25
1. 开发消息模块
   * 系统全局消息(基于Redis存储，BitSet确认已读)
     * 添加
     * 查询
     * 修改
     * 删除
   * 系统通知
   * 用户个人消息
     * Websocket实现实时通讯，基于redis实现未读消息数查询
     * 优化：数据库只存未读消息，读取过的消息直接存于本地SQLite

2023/6/26

大部分模块增删改查

* 需求模块（用户端，审查端）
* 竞拍模块（用户端）
* 收藏需求模块（用户端）

## 数据库设计

>  所有Model都有的属性

### Base Model

主键：id(bigint)

创建时间：create_time(datetime)

更新时间：update_time(datetime)

Model状态: status(tinyint)

 

### User Model

用户名：username（varchar（11））//手机号码

密码：password（varchar（128））//Bcr...加密后的密文

角色：role（tinyint）//0：普通用户，1：管理员

邮箱：email（varchar（32））

标签：tag（varchar（64））//用于搜索

偏好：favour(varchar(64))//用于推荐

昵称：nickname（varchar（16））

头像：avatar（bigint）// resource表 id

签名：signature(varchar(40))



* Index
  * username, id // 联合索引查询id，id再回表，数据量小回表无所谓
  * username //唯一索引



### Resource Model

校验码：md5（char（32））

存储路径：path（varchar（128））

文件类型: content_type(varchar(32))

* Index
  * md5唯一索引



### Message Model

发送人ID：sender_id(bigint)

接收人ID：receiver_id(bigint)

消息附件ID: annex_id(bigint)

消息标题：title(varchar)

消息内容：message(varchar)

消息类型：message_type(tinyint, 0: 系统通知，1: 个人消息)

消息状态：message_condition(tinyint)(0：未读，1：已读)



### Demand Model

创建人：user_id(bigint)

标题: title(varchar)

主题: theme(varchar)

主体: body(varchar)

技术选型: technical_selection(varchar)

预算: budget(bigint)

附件ID: annex_id(bigint)

需求状态: demand_condition(tinyint, 0：竞拍中，1：合作中，2：已完成)



### Compete_Demand Model

竞争者ID：competitor_id(bigint)

需求ID：demand_id(bigint)

描述：description //你有什么优势？为什么你值这个价格？

价格：price(bigint)



### Collect_Demand Model

用户ID: user_id(bigint)

需求ID: demand_id(bigint)



### Cooperate_Demand Model

需求ID：demand_id(bigint)

用户ID：user_id(bigint)

设计师ID：designer_id(bigint)

金额: money(bigint)

死线：dead_time(datetime)

作品ID：works_id(bigint)

作品状态：works_condition(tinyint, 0:未完成, 1:已完成，2：已超时)

支付状态：payment_condition(tinyint, 0:未支付,1:已支付)

* 冗余信息，减少联表



### Works Model

设计师ID：designer_id(bigint)

需求ID: demand_id(bigint)

附件ID: annex_id(bigint)

主体：body(varchar)

评分: grade(tinyint)

评价:evaluate(varchar)



### Collect_Works Model

用户ID：user_id（bigint）

作品ID：works_id（bigint）



### Examine_Demand Model

虚假ID：cheat_id(bigint) //避免多次更新id重复, 记录原ID

标题：title(varchar)

主体：body(varchar)

技术选型: technical_selection(varchar)

预算: budget(bigint)

附件ID: annex_id(bigint)

审核消息：message(varchar)

审核状态：examine_condition(tinyint, NOTNULL)

* 审核表，都可以为空



### Examine_User Model

虚假ID：cheat_id(bigint) //避免重复ID

邮箱：email（varchar（32））

标签：tag（varchar（64））//用于搜索

偏好：favour(varchar(64))//用于推荐

昵称：nickname（varchar（16））

头像：avatar（bigint）// resource表 id

签名：signature(varchar(40))

审核消息：message(varchar)

审核状态：examine_condition(tinyint, NOTNULL)

* 审核表，都可以为空



## 功能开发思路

1. 消息处理

消息分为三种，一种是广播消息（没有实时性，类似于打开页面时的弹窗广告），这种不需要使用WS；第二种是通知类的消息，具有实时性，需要使用WS；第三种是聊天类的消息，具有实时性，需要使用WS。

消息提醒的处理，如果接收方在线，那么直接通过WS发送消息提醒对方接收消息；如果接收方不在线，那么存储在数据库中，当下一次接收方在线时，读取未读消息并通过WS发送；

消息的签收逻辑，WS发送消息不等于已读，因此只有在用户切实的阅读消息后才签收消息。



这时就不得不考虑一个问题，一次性大量的发送离线消息，会造成线程的长时间阻塞，因此，最好通过异步的方式发送消息，在服务器集群的情况下，采用MQ作为中间件即可。



优化：将未读消息数通过Redis进行记录，不再使用Mysql查询



收获：因为部分请求需要异步，此时ThreadLocal就不再存有用户信息了，因此很多时候能给当前用户的ID给前端就直接给，让前端传ID。

​		先创建获得ID，在更新信息时才进行审核。

开发过程中尽量不要为了一点点内存修改model，有可能之后忘记model被修改过，产生bug。



### 竞拍

竞拍类似于评论，可以进行出价和描述自己的优势；但是这与最终雇主的定价并不挂钩，最终价格由设计师和雇主聊天协商达成。



### 收藏需求

用户/设计师可以收藏自己感兴趣的需求，不论是参考还是准备进行竞拍，抑或是合作。



### 用户-设计师确认合作

由用户向设计师发起合作请求，在30分钟内，若设计师通过验证方式确认身份后同意请求则视为开始合作。

